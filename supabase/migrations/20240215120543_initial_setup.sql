create type public.app_role as enum('admin', 'host', 'participant');
create type public.app_permission as enum('events.create', 'events.delete');

-- ..........
--
-- PROFILES
--
-- ..........
create table public.profiles (
  id uuid not null primary key references auth.users (id) on delete cascade,
  name text not null,
  avatar_url text,
  birthmonth integer,
  birthyear integer,
  username text not null unique,
  billing_address jsonb,
  payment_method jsonb
);
-- Comments
comment on table public.profiles is 'Profile data for each user.';
comment on column public.profiles.id is 'References the internal Supabase Auth user.';
comment on column public.profiles.username is 'Unique slug based on username.';
-- RLS
alter table public.profiles enable row level security;
create policy "Can view own user data." on profiles for select using (auth.uid() = id);
create policy "Can update own user data." on profiles for update using (auth.uid() = id);


-- ..........
--
-- CUSTOMERS
-- * Note: this is a private table that contains a mapping of user IDs to Stripe customer IDs.
--
-- ..........
create table customers (
  -- UUID from auth.users
  id uuid references auth.users not null primary key,
  -- The user's customer ID in Stripe. User must not be able to update this.
  stripe_customer_id text
);
alter table customers enable row level security;
-- No policies as this is a private table that the user must not have access to.

-- ............
--
-- USER ROLES
--
-- ............
create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles (id) on delete cascade not null,
  role app_role not null,
  unique (user_id, role)
);
-- Comments
comment on table public.user_roles is 'Application roles for each user.';
-- RLS
alter table public.user_roles enable row level security;
create policy "Users can view their own roles." on user_roles for select using (auth.uid () = user_id);


-- ..................
--
-- ROLE PERMISSIONS
--
-- ..................
create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role app_role not null,
  permission app_permission not null,
  unique (role, permission)
);
-- Comments
comment on table public.role_permissions is 'Application permissions for each role.';
-- RLS
alter table public.role_permissions enable row level security;


-- .........
--
-- EVENTS
--
-- .........
-- Types
create type public.event_status as enum(
  'draft',
  'reserving',
  'reservations-closed',
  'cancelled',
  'completed'
);
create type public.event_categories as enum('speed-dating', 'retreats');
create type public.currencies as enum('sgd');
-- Table
create table public.events (
  id uuid not null default gen_random_uuid () primary key,
  status event_status not null default 'reserving',
  slug text not null unique,
  name text not null,
  description text,
  category event_categories[] not null default array['speed-dating']::event_categories[],
  date_start timestamp with time zone default timezone ('utc'::text, now()) not null,
  date_end timestamp with time zone default timezone ('utc'::text, now()) not null,
  location_name text not null,
  location_address text not null,
  location_country text not null,
  price integer,
  price_currency currencies not null default 'sgd',
  slots integer not null default 0,
  image_thumbnail_url varchar(255),
  image_banner_url varchar(255),
  created_by uuid references public.profiles (id) on delete set null not null,
  created_at timestamp with time zone default timezone ('utc'::text, now()) not null,
  -- Additional information about the event in JSON.
  metadata jsonb
);
-- Comments
comment on table public.events is 'Details for each event.';
-- RLS
alter table events enable row level security;
create policy "Viewable by everyone." on events for select using (true);
create policy "Can update own events." on events for update using (auth.uid () = created_by);
create policy "Can delete own events." on events for delete using (auth.uid () = created_by);
create policy "Admin can delete any event." on events for delete using (exists (select 1 from public.user_roles where user_id = auth.uid() and role = 'admin'));
create policy "Hosts & admins can create events." on events for insert with check (exists (select 1 from public.user_roles where user_roles.user_id = auth.uid() and user_roles.role in ('host', 'admin')));


-- .............
--
-- EVENT PRICES
--
-- .............
  create table prices (
  -- Price ID from Stripe, e.g. price_1234.
  id text primary key,
  event_id uuid references public.events(id), 
  active boolean,
  description text,
  -- The unit amount as a positive integer in the smallest currency unit (e.g., 100 cents for US$1.00 or 100 for Â¥100, a zero-decimal currency).
  unit_amount bigint,
  -- Three-letter ISO currency code, in lowercase.
  currency text check (char_length(currency) = 3),
  -- Additional information about the price in JSON.
  metadata jsonb
);
alter table prices enable row level security;
create policy "Allow public read-only access." on prices for select using (true);


-- ...................
--
-- EVENT PARTICIPANTS
--
-- ...................
create table public.event_participants (
  event_id uuid not null references public.events (id) on delete cascade,
  user_id uuid not null references public.profiles (id) on delete cascade,
  tickets_bought integer not null default 0,
  primary key (event_id, user_id)
);
-- Comments
comment on table public.event_participants is 'List of user IDs participating in an event.';
-- RLS
alter table event_participants enable row level security;
create policy "Event creators and admins can view and edit" on event_participants for all using (
  exists (
    select
      1
    from
      public.events e
      join public.user_roles ur on ur.user_id = auth.uid ()
    where
      e.id = event_participants.event_id
      and (
        e.created_by = auth.uid ()
        or ur.role = 'admin'
      )
  )
);
create policy "Users can add their own sign-up records" on event_participants for insert
with
  check (
    exists (
      select
        1
      from
        public.events
      where
        events.id = event_participants.event_id
    )
  );

-- ....................
--
-- STORAGE
--
-- ....................
insert into
  storage.buckets (id, name, public)
values
  ('avatars', 'avatars', true),
  ('event_thumbnails', 'event_thumbnails', true),
  ('event_banners', 'event_banners', true);
create policy "Public read access for avatars, event thumbnails, and event banners" on storage.objects for select using (bucket_id in ('avatars', 'event_thumbnails', 'event_banners'));
create policy "Public insert access for avatars, event thumbnails, and event banners" on storage.objects for
insert with check (bucket_id in ('avatars', 'event_thumbnails', 'event_banners'));

-- ...........
--
-- FUNCTIONS
--
-- ...........
-- Authorize with role - based access control (RBAC)
create
or replace function public.authorize (requested_permission app_permission, user_id uuid) returns boolean as $$
declare bind_permissions int;
begin
  select count(*)
  from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
  where role_permissions.permission = authorize.requested_permission
    and user_roles.user_id = authorize.user_id into bind_permissions;
  return bind_permissions > 0;
end;
$$ language plpgsql security definer;

-- Automatically creates a user entry when a new user signs up via Supabase Auth.
create
or replace function public.handle_new_user () returns trigger as $$ 
begin
  insert into public.profiles (id, name, avatar_url, birthmonth, birthyear)
  values (
      new.id,
      new.raw_user_meta_data->>'name',
      new.raw_user_meta_data->>'avatar_url',
      new.raw_user_meta_data['birthmonth']::integer,
      new.raw_user_meta_data['birthyear']::integer
    );
  return new;
end;
$$ language plpgsql security definer;

-- Function to generate a unique username slug based on the user's name
create
or replace function public.set_username_slug () returns trigger as $$
declare
    base_slug text;
    new_slug text;
    slug_count int;
begin
    new_slug := slugify(NEW.name);
    slug_count := 1;

    -- Check if the username slug already exists and append a number to make it unique
    loop
        select count(*) into slug_count from public.profiles where username = new_slug;
        exit when slug_count = 0;
        new_slug := new_slug || '-' || slug_count;
        slug_count := slug_count + 1;
    end loop;

    NEW.username := new_slug;
    return NEW;
end;
$$ language plpgsql;

-- Function to generate a unique slug using a text input
create extension if not exists "unaccent";

create
or replace function slugify ("value" text) returns text as $$
  with "unaccented" as (
    select unaccent("value") as "value"
  ),
  "lowercase" as (
    select lower("value") as "value"
    from "unaccented"
  ),
  "removed_quotes" as (
    select regexp_replace("value", '[''"]+', '', 'gi') as "value"
    from "lowercase"
  ),
  "hyphenated" as (
    select regexp_replace("value", '[^a-z0-9\\-_]+', '-', 'gi') as "value"
    from "removed_quotes"
  ),
  "trimmed" as (
    select regexp_replace(regexp_replace("value", '\-+$', ''), '^\-', '') as "value"
    from "hyphenated"
  )
  select "value" from "trimmed";
$$ language sql strict immutable;

-- Create a function to generate and set a unique slug from the event name
create
or replace function public.set_event_slug () returns trigger as $$
declare
    base_slug text;
    new_slug text;
    slug_count int;
begin
    new_slug := slugify(NEW.name);
    slug_count := 1;

    -- Check if the slug already exists and append a number to make it unique
    loop
        select count(*) into slug_count from public.events where slug = new_slug;
        exit when slug_count = 0;
        new_slug := new_slug || '-' || slug_count;
        slug_count := slug_count + 1;
    end loop;

    new.slug := new_slug;
    return new;
end;
$$ language plpgsql;

-- Function to handle user sign-up for an event
create
or replace function public.sign_up_for_event (
  p_event_id uuid,
  p_user_id uuid,
  p_tickets_bought integer
) returns void as $$
declare
    v_event_exists int;
    v_event_slots int;
    v_already_signed_up int;
    v_total_tickets_bought int;
begin
    -- Check if the event exists and retrieve the number of slots
    select count(*), slots into v_event_exists, v_event_slots
    from public.events
    where id = p_event_id
    group by slots;

    if v_event_exists = 0 then
        raise exception 'Event does not exist.';
    end if;

    -- Calculate the total tickets bought for the event
    select coalesce(sum(tickets_bought), 0) into v_total_tickets_bought
    from public.event_participants
    where event_id = p_event_id;

    -- Check if adding the new tickets exceeds the event's slots
    if v_total_tickets_bought + p_tickets_bought > v_event_slots then
        raise exception 'This event is fully signed up.';
    end if;

    -- Check if the user has already signed up for the event
    select count(*) into v_already_signed_up
    from public.event_participants
    where event_id = p_event_id and user_id = p_user_id;

    if v_already_signed_up > 0 then
        -- Update the number of tickets bought if the user has already signed up
        update public.event_participants
        set tickets_bought = tickets_bought + p_tickets_bought
        where event_id = p_event_id and user_id = p_user_id;
    else
        -- Insert a new record into event_participants
        insert into public.event_participants (event_id, user_id, tickets_bought)
        values (p_event_id, p_user_id, p_tickets_bought);
    end if;
end;
$$ language plpgsql;


-- ...........
--
-- TRIGGERS
--
-- ...........
-- Create a trigger to automatically set the username slug before inserting or updating the user's name
create trigger set_username_slug_before_insert_or_update before insert
or
update of name on public.profiles for each row
execute function public.set_username_slug ();

create
or replace trigger on_auth_user_created
after insert on auth.users for each row
execute procedure public.handle_new_user ();

-- Create a trigger to automatically set the slug before inserting or updating the event name
create trigger set_event_slug_before_insert_or_update before insert
or
update of name on public.events for each row
execute function public.set_event_slug ();


-- ...........
--
-- VIEWS
--
-- ...........
-- Creates a view of profiles with their roles
create or replace view profiles_with_roles as
select
  p.id,
  p.name,
  p.avatar_url,
  p.birthmonth,
  p.birthyear,
  p.username,
  array_agg(ur.role) as roles
from
  public.profiles p
  join public.user_roles ur on ur.user_id = p.id
group by
  p.id;

-- Create a view of profiles with their hosted events, roles, total guests hosted, and sign-ups for each event.
create or replace view profiles_with_hosted_events as
select
  p.id,
  p.username,
  p.name,
  p.avatar_url,
  jsonb_agg(
    distinct jsonb_set(
      to_jsonb(e),
      '{sign_ups}',
      to_jsonb(
        (
          select
            count(*)
          from
            public.event_participants ep2
          where
            ep2.event_id = e.id
        )::integer
      )
    )
  ) as hosted_events,
  array_agg(distinct r.role) as user_roles,
  count(distinct ep.event_id) as joined_events_count,
  sum(ep.tickets_bought) as guests_hosted
from
  public.profiles p
  left join public.events e on p.id = e.created_by
  left join public.user_roles r on p.id = r.user_id
  left join public.event_participants ep on e.id = ep.event_id
group by
  p.id;

-- Create a view to list events with host data
create or replace view events_with_host_data as
select
  e.id,
  e.name,
  e.slug,
  e.category,
  e.description,
  e.image_thumbnail_url,
  e.image_banner_url,
  e.created_at,
  e.date_start,
  e.date_end,
  e.location_name,
  e.location_address,
  e.location_country,
  e.price,
  e.price_currency,
  e.status,
  e.slots,
  json_build_object(
    'id',
    p.id,
    'name',
    p.name,
    'username',
    p.username,
    'avatar_url',
    p.avatar_url,
    'events_created',
    ec.events_created,
    'guests_hosted',
    gh.guests_hosted
  ) as created_by,
  coalesce(ep.sign_ups, 0) as sign_ups
from
  public.events e
  left join public.profiles p on p.id = e.created_by
  left join (
    select
      created_by,
      count(id) as events_created
    from
      public.events
    group by
      created_by
  ) ec on ec.created_by = p.id
  left join (
    select
      e.created_by,
      sum(ep.tickets_bought) as guests_hosted
    from
      public.events e
      join public.event_participants ep on e.id = ep.event_id
    group by
      e.created_by
  ) gh on gh.created_by = p.id
  left join (
    select
      event_id,
      sum(tickets_bought) as sign_ups
    from
      public.event_participants
    group by
      event_id
  ) ep on e.id = ep.event_id;

drop publication if exists supabase_realtime;
create publication supabase_realtime for table events, prices;