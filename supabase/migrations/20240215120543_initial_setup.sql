create type public.app_role as enum('admin', 'host', 'participant');

create type public.app_permission as enum('events.create', 'events.delete');

-- ..........
--
-- PROFILES
--
-- ..........
create table public.profiles (
  id uuid not null primary key references auth.users (id) on delete cascade,
  stripe_customer_id text,
  name text not null,
  avatar_url text,
  birthmonth integer,
  birthyear integer,
  username text not null unique,
  billing_address jsonb,
  payment_method jsonb
);

-- Comments
comment on table public.profiles is 'Profile data for each user.';

comment on column public.profiles.id is 'References the internal Supabase Auth user.';

comment on column public.profiles.username is 'Unique slug based on username.';

-- ............
--
-- USER ROLES
--
-- ............
create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles (id) on delete cascade not null,
  role app_role not null,
  unique (user_id, role)
);

-- Comments
comment on table public.user_roles is 'Application roles for each user.';

-- User roles RLS
alter table public.user_roles enable row level security;

create policy "Users can view their own roles." on user_roles for
select
  using (auth.uid () = user_id);

-- Profile RLS
alter table public.profiles enable row level security;

create policy "Admins, hosts and users can view user profile." on profiles for
select
  using (
    auth.uid () = id
    OR exists (
      select
        1
      from
        public.user_roles
      where
        user_id = auth.uid ()
        and role in ('host', 'admin')
    )
  );

create policy "Can update own user data." on profiles
for update
  using (
    auth.uid () = id
    OR exists (
      select
        1
      from
        public.user_roles
      where
        user_id = auth.uid ()
        and role = 'admin'
    )
  );

-- ..................
--
-- ROLE PERMISSIONS
--
-- ..................
create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role app_role not null,
  permission app_permission not null,
  unique (role, permission)
);

-- Comments
comment on table public.role_permissions is 'Application permissions for each role.';

-- RLS
alter table public.role_permissions enable row level security;

-- .........
--
-- EVENTS
--
-- .........
-- Types
create type public.event_status as enum(
  'draft',
  'reserving',
  'reservations-closed',
  'cancelled',
  'completed'
);

create type public.event_categories as enum('speed-dating', 'retreats');

create type public.currencies as enum('sgd');

-- Table
create table public.events (
  id uuid not null default gen_random_uuid () primary key,
  status event_status not null default 'reserving',
  slug text not null unique,
  name text not null,
  description text,
  category event_categories[] not null default array['speed-dating']::event_categories[],
  date_start timestamp with time zone default timezone ('utc'::text, now()) not null,
  date_end timestamp with time zone default timezone ('utc'::text, now()) not null,
  location_name text not null,
  location_address text not null,
  location_country text not null,
  price integer,
  price_currency text check (char_length(price_currency) = 3) not null default 'sgd',
  price_stripe_id text,
  slots integer not null default 0,
  image_thumbnail_url varchar(255),
  image_banner_url varchar(255),
  created_by uuid references public.profiles (id) on delete set null not null,
  created_at timestamp with time zone default timezone ('utc'::text, now()) not null,
  -- Additional information about the event in JSON.
  metadata jsonb
);

-- Comments
comment on table public.events is 'Details for each event.';

-- RLS
alter table events enable row level security;

create policy "Viewable by everyone." on events for
select
  using (true);

create policy "Can update own events." on events
for update
  using (auth.uid () = created_by);

create policy "Can delete own events." on events for delete using (auth.uid () = created_by);

create policy "Admin can delete any event." on events for delete using (
  exists (
    select
      1
    from
      public.user_roles
    where
      user_id = auth.uid ()
      and role = 'admin'
  )
);

create policy "Hosts & admins can create events." on events for insert
with
  check (
    exists (
      select
        1
      from
        public.user_roles
      where
        user_roles.user_id = auth.uid ()
        and user_roles.role in ('host', 'admin')
    )
  );

-- ...................
--
-- EVENT RESERVATIONS
--
-- ...................
create table public.event_reservations (
  id uuid not null default gen_random_uuid () primary key,
  stripe_session_id text,
  stripe_payment_id text,
  payment_amount integer,
  payment_currency text,
  event_id uuid not null references public.events (id) on delete cascade,
  user_id uuid not null references public.profiles (id) on delete cascade,
  tickets_bought integer not null default 0,
  reservation_status text not null default 'pending',
  payment_status text not null default 'unpaid',
  reservation_expires_at timestamp with time zone default (now() + interval '10 minutes')
);

-- Comments
comment on table public.event_reservations is 'Reservations for an event';

comment on column public.event_reservations.reservation_status is 'Status of the reservation (pending, confirmed, cancelled)';

comment on column public.event_reservations.payment_status is 'Status of the payment (unpaid, paid, refunded)';

comment on column public.event_reservations.reservation_expires_at is 'Timestamp when the reservation expires if not paid';

-- RLS
alter table event_reservations enable row level security;

create policy "Event creators, admins, and users can view their reservations" on event_reservations for
select
  using (
    exists (
      select
        1
      from
        public.events e
        join public.user_roles ur on ur.user_id = auth.uid ()
      where
        e.id = event_reservations.event_id
        and (
          e.created_by = auth.uid ()
          or ur.role = 'admin'
          or event_reservations.user_id = auth.uid ()
        )
    )
  );

create policy "Users, Admins, and Hosts can add their own sign-up records" on event_reservations for insert
with
  check (
    exists (
      select
        1
      from
        public.events e
        join public.user_roles ur on ur.user_id = auth.uid()
      where
        e.id = event_reservations.event_id
        and (
          ur.role = 'admin'
          or ur.role = 'host'
          or event_reservations.user_id = auth.uid()
        )
    )
  );

-- ....................
--
-- STORAGE
--
-- ....................
insert into
  storage.buckets (id, name, public)
values
  ('avatars', 'avatars', true),
  ('event_thumbnails', 'event_thumbnails', true),
  ('event_banners', 'event_banners', true);

create policy "Public read access for avatars, event thumbnails, and event banners" on storage.objects for
select
  using (
    bucket_id in ('avatars', 'event_thumbnails', 'event_banners')
  );

create policy "Public insert access for avatars, event thumbnails, and event banners" on storage.objects for insert
with
  check (
    bucket_id in ('avatars', 'event_thumbnails', 'event_banners')
  );

-- ...........
--
-- FUNCTIONS
--
-- ...........
-- Authorize with role - based access control (RBAC)
create
or replace function public.authorize (requested_permission app_permission, user_id uuid) returns boolean as $$
declare bind_permissions int;
begin
  select count(*)
  from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
  where role_permissions.permission = authorize.requested_permission
    and user_roles.user_id = authorize.user_id into bind_permissions;
  return bind_permissions > 0;
end;
$$ language plpgsql security definer;

-- Automatically creates a user entry when a new user signs up via Supabase Auth.
create
or replace function public.handle_new_user () returns trigger as $$ 
begin
  insert into public.profiles (id, name, avatar_url, birthmonth, birthyear)
  values (
      new.id,
      new.raw_user_meta_data->>'name',
      new.raw_user_meta_data->>'avatar_url',
      new.raw_user_meta_data['birthmonth']::integer,
      new.raw_user_meta_data['birthyear']::integer
    );
  return new;
end;
$$ language plpgsql security definer;

-- Function to generate a unique username slug based on the user's name
create
or replace function public.set_username_slug () returns trigger as $$
declare
    base_slug text;
    new_slug text;
    slug_count int;
begin
    new_slug := slugify(NEW.name);
    slug_count := 1;

    -- Check if the username slug already exists and append a number to make it unique
    loop
        select count(*) into slug_count from public.profiles where username = new_slug;
        exit when slug_count = 0;
        new_slug := new_slug || '-' || slug_count;
        slug_count := slug_count + 1;
    end loop;

    NEW.username := new_slug;
    return NEW;
end;
$$ language plpgsql;

-- Function to generate a unique slug using a text input
create extension if not exists "unaccent";

create
or replace function slugify ("value" text) returns text as $$
  with "unaccented" as (
    select unaccent("value") as "value"
  ),
  "lowercase" as (
    select lower("value") as "value"
    from "unaccented"
  ),
  "removed_quotes" as (
    select regexp_replace("value", '[''"]+', '', 'gi') as "value"
    from "lowercase"
  ),
  "hyphenated" as (
    select regexp_replace("value", '[^a-z0-9\\-_]+', '-', 'gi') as "value"
    from "removed_quotes"
  ),
  "trimmed" as (
    select regexp_replace(regexp_replace("value", '\-+$', ''), '^\-', '') as "value"
    from "hyphenated"
  )
  select "value" from "trimmed";
$$ language sql strict immutable;

-- Create a function to generate and set a unique slug from the event name
create
or replace function public.set_event_slug () returns trigger as $$
declare
    base_slug text;
    new_slug text;
    slug_count int;
begin
    new_slug := slugify(NEW.name);
    slug_count := 1;

    -- Check if the slug already exists and append a number to make it unique
    loop
        select count(*) into slug_count from public.events where slug = new_slug;
        exit when slug_count = 0;
        new_slug := new_slug || '-' || slug_count;
        slug_count := slug_count + 1;
    end loop;

    new.slug := new_slug;
    return new;
end;
$$ language plpgsql;

-- Function to handle user sign-up for an event, only creating a reservation record
create
or replace function public.sign_up_for_event (
  p_event_id uuid,
  p_stripe_session_id text,
  p_user_id uuid,
  p_tickets_bought integer
) returns void as $$
declare
    v_event_slots int;
    v_tickets_bought int;
    v_total_tickets_bought int;
begin
    -- Retrieve the total slots and currently occupied slots for the event
    select slots, coalesce(sum(tickets_bought), 0) into v_event_slots, v_total_tickets_bought
    from public.events
    join public.event_reservations on public.events.id = public.event_reservations.event_id
    where public.events.id = p_event_id
    group by public.events.slots;

    -- Check if adding the new tickets exceeds the event's slots
    if v_total_tickets_bought + v_tickets_bought > v_event_slots then
        raise exception 'This event is fully signed up.';
    end if;

      -- Insert a new record and return the id
      insert into public.event_reservations (event_id, stripe_session_id, user_id, tickets_bought, reservation_status, payment_status)
      values (p_event_id, p_stripe_session_id, p_user_id, p_tickets_bought, 'pending', 'unpaid');
end;
$$ language plpgsql;

-- Function to update statuses after payment is confirmed
create
or replace function public.after_payment_confirmed (
  p_stripe_session_id text,
  p_stripe_payment_id text
) returns void as $$
begin
    update public.event_reservations
    set 
      reservation_status = 'confirmed',
      payment_status = 'paid',
      stripe_payment_id = p_stripe_payment_id
    where stripe_session_id = p_stripe_session_id;

end;
$$ language plpgsql;

-- ...........
--
-- TRIGGERS
--
-- ...........
-- Create a trigger to automatically set the username slug before inserting or updating the user's name
create trigger set_username_slug_before_insert_or_update before insert
or
update of name on public.profiles for each row
execute function public.set_username_slug ();

create
or replace trigger on_auth_user_created
after insert on auth.users for each row
execute procedure public.handle_new_user ();

-- Create a trigger to automatically set the slug before inserting or updating the event name
create trigger set_event_slug_before_insert_or_update before insert
or
update of name on public.events for each row
execute function public.set_event_slug ();

-- ...........
--
-- VIEWS
--
-- ...........
-- Creates a view of profiles with their roles
create or replace view profiles_with_roles as
select
  p.id,
  p.name,
  p.avatar_url,
  p.birthmonth,
  p.birthyear,
  p.username,
  array_agg(ur.role) as roles
from
  public.profiles p
  join public.user_roles ur on ur.user_id = p.id
  left join public.event_reservations ep on ep.user_id = p.id
  left join public.events e on e.id = ep.event_id
group by
  p.id;

-- Create or replace view of profiles with events hosted or signed up for, including reservations
create or replace view profiles_with_events as
select
  p.id,
  p.username,
  p.name,
  p.avatar_url,
  coalesce(
    jsonb_agg(
      jsonb_set(
        to_jsonb(e),
        '{sign_ups}',
        to_jsonb(
          (
            select
              count(*)
            from
              public.event_reservations ep2
            where
              ep2.event_id = e.id
          )::integer
        )
      ) ORDER BY e.date_start DESC
    ) FILTER (
      WHERE
        e.id IS NOT NULL
    ),
    '[]'::jsonb
  ) as events_hosted,
  coalesce(
    jsonb_agg(
      jsonb_set(
        jsonb_set(
          to_jsonb(e2),
          '{created_by}',
          to_jsonb(
            (
              select
                p2.name
              from
                public.profiles p2
              where
                p2.id = e2.created_by
            )
          )
        ),
        '{reservations}',
        to_jsonb(
          (
            select
              array_agg(
                to_jsonb(er.*)
              )
            from
              public.event_reservations er
            where
              er.user_id = p.id and er.event_id = e2.id
          )
        )
      ) ORDER BY e2.date_start DESC
    ) FILTER (
      WHERE
        e2.id IS NOT NULL
    ),
    '[]'::jsonb
  ) as events_joined,
  array_agg(distinct r.role) as user_roles,
  count(ep.event_id) as events_joined_count,
  (
    select
      sum(er.tickets_bought)
    from
      public.event_reservations er
    join
      public.events ev on er.event_id = ev.id
    where
      ev.created_by = p.id
  ) as guests_hosted
from
  public.profiles p
  left join public.events e on p.id = e.created_by
  left join public.user_roles r on p.id = r.user_id
  left join public.event_reservations ep on p.id = ep.user_id
  left join public.events e2 on e2.id = ep.event_id
group by
  p.id;

-- Create a view to list events with host data
create or replace view events_with_host_data as
select
  e.id,
  e.name,
  e.slug,
  e.category,
  e.description,
  e.image_thumbnail_url,
  e.image_banner_url,
  e.created_at,
  e.date_start,
  e.date_end,
  e.location_name,
  e.location_address,
  e.location_country,
  e.price,
  e.price_currency,
  e.price_stripe_id,
  e.status,
  e.slots,
  json_build_object(
    'id',
    p.id,
    'name',
    p.name,
    'username',
    p.username,
    'avatar_url',
    p.avatar_url,
    'events_created',
    ec.events_created,
    'guests_hosted',
    gh.guests_hosted
  ) as created_by,
  coalesce(ep.sign_ups, 0) as sign_ups
from
  public.events e
  left join public.profiles p on p.id = e.created_by
  left join (
    select
      created_by,
      count(id) as events_created
    from
      public.events
    group by
      created_by
  ) ec on ec.created_by = p.id
  left join (
    select
      e.created_by,
      sum(ep.tickets_bought) as guests_hosted
    from
      public.events e
      join public.event_reservations ep on e.id = ep.event_id
    group by
      e.created_by
  ) gh on gh.created_by = p.id
  left join (
    select
      event_id,
      sum(tickets_bought) as sign_ups
    from
      public.event_reservations
    group by
      event_id
  ) ep on e.id = ep.event_id;

drop publication if exists supabase_realtime;

create publication supabase_realtime for table events;