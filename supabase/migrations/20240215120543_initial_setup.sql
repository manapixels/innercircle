create type public.app_role as enum('admin', 'host', 'participant');

create type public.app_permission as enum('events.create', 'events.delete');

create type public.event_status as enum(
  'draft',
  'reserving',
  'reservations-closed',
  'cancelled',
  'completed'
);

create type public.event_categories as enum('speed-dating', 'retreats');

create type public.currencies as enum('sgd');

-- ........
-- PROFILE
-- ........
create table public.profiles (
  id uuid not null primary key references auth.users (id) on delete cascade,
  name text not null,
  avatar_url text,
  birthmonth integer,
  birthyear integer,
  username text not null unique
);

comment on table public.profiles is 'Profile data for each user.';

comment on column public.profiles.id is 'References the internal Supabase Auth user.';

comment on column public.profiles.username is 'Unique slug based on the user name.';

-- ............
-- USER ROLES
-- ............
create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles (id) on delete cascade not null,
  role app_role not null,
  unique (user_id, role)
);

comment on table public.user_roles is 'Application roles for each user.';

-- ..................
-- ROLE PERMISSIONS
-- ..................
create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role app_role not null,
  permission app_permission not null,
  unique (role, permission)
);

comment on table public.role_permissions is 'Application permissions for each role.';

-- .........
-- EVENTS
-- .........
create table public.events (
  id uuid not null default gen_random_uuid () primary key,
  status event_status not null default 'reserving',
  slug text not null unique,
  name text not null,
  description text,
  category event_categories not null default 'speed-dating',
  date_start timestamp with time zone default timezone ('utc'::text, now()) not null,
  date_end timestamp with time zone default timezone ('utc'::text, now()) not null,
  location_name text not null,
  location_address text not null,
  location_country text not null,
  price integer,
  price_currency currencies not null default 'sgd',
  slots integer not null default 0,
  image_thumbnail_url varchar(255),
  image_banner_url varchar(255),
  created_by uuid references public.profiles (id) on delete set null not null,
  created_at timestamp with time zone default timezone ('utc'::text, now()) not null
);

comment on table public.events is 'Details for each event.';

create table public.event_participants (
  event_id uuid not null references public.events (id) on delete cascade,
  user_id uuid not null references public.profiles (id) on delete cascade,
  tickets_bought integer not null default 0,
  primary key (event_id, user_id)
);

comment on table public.event_participants is 'List of user IDs participating in an event.';

-- ....................
--
-- STORAGE
--
-- ....................
insert into
  storage.buckets (id, name, public)
values
  ('avatars', 'avatars', true),
  ('event_thumbnails', 'event_thumbnails', true),
  ('event_banners', 'event_banners', true);

-- ...........
--
-- FUNCTIONS
--
-- ...........
-- Authorize with role - based access control (RBAC)
create
or replace function public.authorize (requested_permission app_permission, user_id uuid) returns boolean as $$
declare bind_permissions int;
begin
  select count(*)
  from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
  where role_permissions.permission = authorize.requested_permission
    and user_roles.user_id = authorize.user_id into bind_permissions;
  return bind_permissions > 0;
end;
$$ language plpgsql security definer;

-- Automatically creates a user entry when a new user signs up via Supabase Auth.
create
or replace function public.handle_new_user () returns trigger as $$ 
begin
  insert into public.profiles (id, name, avatar_url, birthmonth, birthyear)
  values (
      new.id,
      new.raw_user_meta_data->>'name',
      new.raw_user_meta_data->>'avatar_url',
      new.raw_user_meta_data['birthmonth']::integer,
      new.raw_user_meta_data['birthyear']::integer
    );
  return new;
end;
$$ language plpgsql security definer;

-- Function to generate a unique username slug based on the user's name
create
or replace function public.set_username_slug () returns trigger as $$
declare
    base_slug text;
    new_slug text;
    slug_count int;
begin
    new_slug := slugify(NEW.name);
    slug_count := 1;

    -- Check if the username slug already exists and append a number to make it unique
    loop
        select count(*) into slug_count from public.profiles where username = new_slug;
        exit when slug_count = 0;
        new_slug := new_slug || '-' || slug_count;
        slug_count := slug_count + 1;
    end loop;

    NEW.username := new_slug;
    return NEW;
end;
$$ language plpgsql;

-- Create a trigger to automatically set the username slug before inserting or updating the user's name
create trigger set_username_slug_before_insert_or_update before insert
or
update of name on public.profiles for each row
execute function public.set_username_slug ();

create
or replace trigger on_auth_user_created
after insert on auth.users for each row
execute procedure public.handle_new_user ();

-- Function to generate a unique slug using a text input
create extension if not exists "unaccent";

create
or replace function slugify ("value" text) returns text as $$
  with "unaccented" as (
    select unaccent("value") as "value"
  ),
  "lowercase" as (
    select lower("value") as "value"
    from "unaccented"
  ),
  "removed_quotes" as (
    select regexp_replace("value", '[''"]+', '', 'gi') as "value"
    from "lowercase"
  ),
  "hyphenated" as (
    select regexp_replace("value", '[^a-z0-9\\-_]+', '-', 'gi') as "value"
    from "removed_quotes"
  ),
  "trimmed" as (
    select regexp_replace(regexp_replace("value", '\-+$', ''), '^\-', '') as "value"
    from "hyphenated"
  )
  select "value" from "trimmed";
$$ language sql strict immutable;

-- Create a function to generate and set a unique slug from the event name
create
or replace function public.set_event_slug () returns trigger as $$
declare
    base_slug text;
    new_slug text;
    slug_count int;
begin
    new_slug := slugify(NEW.name);
    slug_count := 1;

    -- Check if the slug already exists and append a number to make it unique
    loop
        select count(*) into slug_count from public.events where slug = new_slug;
        exit when slug_count = 0;
        new_slug := new_slug || '-' || slug_count;
        slug_count := slug_count + 1;
    end loop;

    new.slug := new_slug;
    return new;
end;
$$ language plpgsql;

-- Create a trigger to automatically set the slug before inserting or updating the event name
create trigger set_event_slug_before_insert_or_update before insert
or
update of name on public.events for each row
execute function public.set_event_slug ();

-- Function to handle user sign-up for an event
create
or replace function public.sign_up_for_event (
  p_event_id uuid,
  p_user_id uuid,
  p_tickets_bought integer
) returns void as $$
declare
    v_event_exists int;
    v_event_slots int;
    v_already_signed_up int;
    v_total_tickets_bought int;
begin
    -- Check if the event exists and retrieve the number of slots
    select count(*), slots into v_event_exists, v_event_slots
    from public.events
    where id = p_event_id
    group by slots;

    if v_event_exists = 0 then
        raise exception 'Event does not exist.';
    end if;

    -- Calculate the total tickets bought for the event
    select coalesce(sum(tickets_bought), 0) into v_total_tickets_bought
    from public.event_participants
    where event_id = p_event_id;

    -- Check if adding the new tickets exceeds the event's slots
    if v_total_tickets_bought + p_tickets_bought > v_event_slots then
        raise exception 'This event is fully signed up.';
    end if;

    -- Check if the user has already signed up for the event
    select count(*) into v_already_signed_up
    from public.event_participants
    where event_id = p_event_id and user_id = p_user_id;

    if v_already_signed_up > 0 then
        -- Update the number of tickets bought if the user has already signed up
        update public.event_participants
        set tickets_bought = tickets_bought + p_tickets_bought
        where event_id = p_event_id and user_id = p_user_id;
    else
        -- Insert a new record into event_participants
        insert into public.event_participants (event_id, user_id, tickets_bought)
        values (p_event_id, p_user_id, p_tickets_bought);
    end if;
end;
$$ language plpgsql;


-- Creates a view of profiles with their roles
CREATE OR REPLACE VIEW profiles_with_roles AS
SELECT
  p.id,
  p.name,
  p.avatar_url,
  p.birthmonth,
  p.birthyear,
  p.username,
  array_agg(ur.role) AS roles
FROM
  public.profiles p
JOIN
  public.user_roles ur ON ur.user_id = p.id
GROUP BY
  p.id;

-- Create a view of profiles with their hosted events, roles, and total guests hosted.
CREATE VIEW profiles_with_hosted_events AS
SELECT
  p.id,
  p.username,
  p.name,
  p.avatar_url,
  array_agg(DISTINCT e.*) AS hosted_events,
  array_agg(DISTINCT r.role) AS user_roles,
  count(DISTINCT ep.event_id) AS joined_events_count,
  sum(ep.tickets_bought) AS guests_hosted
FROM
  public.profiles p
  LEFT JOIN public.events e ON p.id = e.created_by
  LEFT JOIN public.user_roles r ON p.id = r.user_id
  LEFT JOIN public.event_participants ep ON e.id = ep.event_id
GROUP BY
  p.id;

-- Create a view to list events with host data
create or replace view events_with_host_data as
select
  e.id,
  e.name,
  e.slug,
  e.image_thumbnail_url,
  e.image_banner_url,
  e.created_at,
  e.date_start,
  e.date_end,
  e.location_name,
  e.location_address,
  e.location_country,
  e.price,
  e.status,
  e.slots,
  json_build_object(
    'id', p.id,
    'name', p.name,
    'username', p.username,
    'avatar_url', p.avatar_url,
    'events_created', ec.events_created,
    'guests_hosted', gh.guests_hosted
  ) as created_by,
  coalesce(ep.sign_ups, 0) as sign_ups
from
  public.events e
  left join public.profiles p on p.id = e.created_by
  left join (
    select
      created_by,
      count(id) as events_created
    from
      public.events
    group by
      created_by
  ) ec on ec.created_by = p.id
  left join (
    select
      e.created_by,
      sum(ep.tickets_bought) as guests_hosted
    from
      public.events e
      join public.event_participants ep on e.id = ep.event_id
    group by
      e.created_by
  ) gh on gh.created_by = p.id
  left join (
    select
      event_id,
      sum(tickets_bought) as sign_ups
    from
      public.event_participants
    group by
      event_id
  ) ep on e.id = ep.event_id;

-- ...................
--
-- Secure the tables
--
-- ...................
-- public.profiles
alter table public.profiles enable row level security;

alter table public.user_roles enable row level security;

alter table public.role_permissions enable row level security;

create policy "Public profiles are viewable by everyone." on profiles for
select
  using (true);

create policy "Users can insert their own profile." on profiles for insert
with
  check (auth.uid () = id);

create policy "Users can update own profile." on profiles
for update
  using (auth.uid () = id);

create policy "Users can view their own roles." on user_roles for
select
  using (auth.uid () = user_id);

-- storage
create policy "Avatar images are publicly accessible." on storage.objects for
select
  using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects for insert
with
  check (bucket_id = 'avatars');

create policy "Event thumbnail images are publicly accessible." on storage.objects for
select
  using (bucket_id = 'event_thumbnails');

create policy "Anyone can upload an event thumbnail." on storage.objects for insert
with
  check (bucket_id = 'event_thumbnails');

create policy "Event banner images are publicly accessible." on storage.objects for
select
  using (bucket_id = 'event_banners');

create policy "Anyone can upload an event banner." on storage.objects for insert
with
  check (bucket_id = 'event_banners');

-- events
alter table events enable row level security;

create policy "Public events are viewable by everyone." on events for
select
  using (true);

create policy "Only hosts and admins can create events." on events for insert
with check (
  exists (
    select 1
    from public.user_roles
    where user_roles.user_id = auth.uid()
    and user_roles.role in ('host', 'admin')
  )
);

create policy "Individuals can update their own events." on events
for update
  using (auth.uid () = created_by);

create policy "Individuals can delete their own events." on events for delete using (auth.uid () = created_by);

create policy "Authorized user can delete any event." on events for delete using (authorize ('events.delete', auth.uid ()));
