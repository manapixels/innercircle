create type public.app_role as enum ('admin', 'participant');
create type public.app_permission as enum ('events.create', 'events.delete');
create type public.event_status as enum (
  'draft',
  'reserving',
  'reservations-closed',
  'cancelled',
  'completed'
);
create type public.event_categories as enum (
  'speed-dating',
  'retreats'
);
create type public.currencies as enum (
  'sgd'
);
-- ........
-- PROFILE
-- ........
create table public.profiles (
  id                uuid not null primary key references auth.users(id) on delete cascade,
  name              text,
  avatar_url        text,
  birthmonth        integer,
  birthyear         integer
);
comment on table public.profiles is 'Profile data for each user.';
comment on column public.profiles.id is 'References the internal Supabase Auth user.';
-- ............
-- USER ROLES
-- ............
create table public.user_roles (
  id                bigint generated by default as identity primary key,
  user_id           uuid references public.profiles(id) on delete cascade not null,
  role              app_role not null,
  unique            (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';
-- ..................
-- ROLE PERMISSIONS
-- ..................
create table public.role_permissions (
  id                bigint generated by default as identity primary key,
  role              app_role not null,
  permission        app_permission not null,
  unique            (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';
-- .........
-- EVENTS
-- .........
create table public.events (
  id                uuid not null default gen_random_uuid() primary key,
  slug              text not null unique,
  status            event_status not null default 'draft',
  date_start        timestamp with time zone default timezone('utc'::text, now()) not null,
  date_end          timestamp with time zone default timezone('utc'::text, now()) not null,
  category          event_categories not null default 'speed-dating',
  location_name     text not null,
  location_address  text not null,
  location_country  text not null,
  name              text not null,
  description       text,
  price             integer,
  price_currency    currencies not null default 'sgd',
  slots             integer not null default 0, 
  image_url         varchar(255),
  created_by        uuid references public.profiles(id) on delete set null not null,
  created_at        timestamp with time zone default timezone('utc'::text, now()) not null
);
comment on table public.events is 'Details for each event.';

create table public.event_participants (
  event_id          uuid not null references public.events(id) on delete cascade,
  user_id           uuid not null references public.profiles(id) on delete cascade,
  tickets_bought    integer not null default 0,
  primary key       (event_id, user_id)
);
comment on table public.event_participants is 'List of user IDs participating in an event.';

-- ....................
--
-- STORAGE
--
-- ....................
insert into storage.buckets (id, name)
values ('avatars', 'avatars');


-- ...........
--
-- FUNCTIONS
--
-- ...........

-- Authorize with role - based access control (RBAC)
create or replace function public.authorize(
    requested_permission app_permission,
    user_id uuid
  ) returns boolean as $$
declare bind_permissions int;
begin
  select count(*)
  from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
  where role_permissions.permission = authorize.requested_permission
    and user_roles.user_id = authorize.user_id into bind_permissions;
  return bind_permissions > 0;
end;
$$ language plpgsql security definer;

-- Automatically reates a user entry when a new user signs up via Supabase Auth.
create or replace function public.handle_new_user() returns trigger as $$ 
begin
  insert into public.profiles (id, name, avatar_url, birthmonth, birthyear)
  values (
      new.id,
      new.raw_user_meta_data->>'name',
      new.raw_user_meta_data->>'avatar_url',
      new.raw_user_meta_data['birthmonth']::integer,
      new.raw_user_meta_data['birthyear']::integer
    );
  return new;
end;
$$ language plpgsql security definer;

create or replace trigger on_auth_user_created
  after insert on auth.users for each row 
  execute procedure public.handle_new_user();

-- Function to generate a unique slug using a text input
create extension if not exists "unaccent";
create or replace function slugify("value" text)
returns text as $$
  with "unaccented" as (
    select unaccent("value") as "value"
  ),
  "lowercase" as (
    select lower("value") as "value"
    from "unaccented"
  ),
  "removed_quotes" as (
    select regexp_replace("value", '[''"]+', '', 'gi') as "value"
    from "lowercase"
  ),
  "hyphenated" as (
    select regexp_replace("value", '[^a-z0-9\\-_]+', '-', 'gi') as "value"
    from "removed_quotes"
  ),
  "trimmed" as (
    select regexp_replace(regexp_replace("value", '\-+$', ''), '^\-', '') as "value"
    from "hyphenated"
  )
  select "value" from "trimmed";
$$ language sql strict immutable;

-- Create a function to generate and set a unique slug from the event name
create or replace function public.set_event_slug() returns trigger as $$
declare
    base_slug text;
    new_slug text;
    slug_count int;
begin
    new_slug := slugify(NEW.name);
    slug_count := 1;

    -- Check if the slug already exists and append a number to make it unique
    loop
        select count(*) into slug_count from public.events where slug = new_slug;
        exit when slug_count = 0;
        new_slug := new_slug || '-' || slug_count;
        slug_count := slug_count + 1;
    end loop;

    new.slug := new_slug;
    return new;
end;
$$ language plpgsql;

-- Create a trigger to automatically set the slug before inserting or updating the event name
create trigger set_event_slug_before_insert_or_update
before insert or update of name on public.events
for each row execute function public.set_event_slug();

-- Function to handle user sign-up for an event
create or replace function public.sign_up_for_event(
    p_event_id uuid,
    p_user_id uuid,
    p_tickets_bought integer
) returns void as $$
declare
    v_event_exists int;
    v_already_signed_up int;
begin
    -- Check if the event exists
    select count(*) into v_event_exists
    from public.events
    where id = p_event_id;

    if v_event_exists = 0 then
        raise exception 'Event does not exist.';
    end if;

    -- Check if the user has already signed up for the event
    select count(*) into v_already_signed_up
    from public.event_participants
    where event_id = p_event_id and user_id = p_user_id;

    if v_already_signed_up > 0 then
        -- Update the number of tickets bought if the user has already signed up
        update public.event_participants
        set tickets_bought = tickets_bought + p_tickets_bought
        where event_id = p_event_id and user_id = p_user_id;
    else
        -- Insert a new record into event_participants
        insert into public.event_participants (event_id, user_id, tickets_bought)
        values (p_event_id, p_user_id, p_tickets_bought);
    end if;
end;
$$ language plpgsql;

create view events_with_host_data as
select
  e.id, e.name, e.image_url, e.created_at, e.date_start, e.date_end, e.location_name, e.location_address, e.location_country, e.price, e.status, e.slots,
  json_build_object(
    'id', p.id,
    'name', p.name,
    'avatar_url', p.avatar_url,
    'events_created', ec.events_created,
    'guests_hosted', gh.guests_hosted
  ) as created_by
from public.events e
left join public.profiles p on p.id = e.created_by
left join (
  select
    created_by,
    count(id) as events_created
  from public.events
  group by created_by
) ec on ec.created_by = p.id
left join (
  select
    e.created_by,
    sum(ep.tickets_bought) as guests_hosted
  from public.events e
  join public.event_participants ep on e.id = ep.event_id
  group by e.created_by
) gh on gh.created_by = p.id;

-- ...................
--
-- Secure the tables
--
-- ...................

-- public.profiles
alter table public.profiles enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
create policy "Public profiles are viewable by everyone." on profiles for select using (true);
create policy "Users can insert their own profile." on profiles for insert with check (auth.uid() = id);
create policy "Users can update own profile." on profiles for update using (auth.uid() = id);

-- storage
create policy "Avatar images are publicly accessible." on storage.objects for
select using (bucket_id = 'avatars');
create policy "Anyone can upload an avatar." on storage.objects for
insert with check (bucket_id = 'avatars');

-- events
alter table events enable row level security;
create policy "Public events are viewable by everyone." on events for select using (true);
create policy "Individuals can create events." on events for
insert with check (auth.uid() = created_by);
create policy "Individuals can update their own events." on events for
update using (auth.uid() = created_by);
create policy "Individuals can delete their own events." on events for delete using (auth.uid() = created_by);
create policy "Authorized user can delete any event." on events for delete using (authorize('events.delete', auth.uid()));